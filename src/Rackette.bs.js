// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Read$Rackette = require("./Read.bs.js");
var CS17SetupRackettePREDESIGNCHECK$Rackette = require("./CS17SetupRackettePREDESIGNCHECK.bs.js");

function plus(alon) {
  if (!alon) {
    return Pervasives.failwith("'+' expects two number values");
  }
  var a = alon.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("'+' expects two number values");
  }
  var match = alon.tl;
  if (!match) {
    return Pervasives.failwith("'+' expects two number values");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* NumV */0,
            _0: a._0 + b._0 | 0
          };
  } else {
    return Pervasives.failwith("'+' expects two number values");
  }
}

function minus(alon) {
  if (!alon) {
    return Pervasives.failwith("'-' expects two number values");
  }
  var a = alon.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("'-' expects two number values");
  }
  var match = alon.tl;
  if (!match) {
    return Pervasives.failwith("'-' expects two number values");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* NumV */0,
            _0: a._0 - b._0 | 0
          };
  } else {
    return Pervasives.failwith("'-' expects two number values");
  }
}

function mult(alon) {
  if (!alon) {
    return Pervasives.failwith("'*' expects two number values");
  }
  var a = alon.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("'*' expects two number values");
  }
  var match = alon.tl;
  if (!match) {
    return Pervasives.failwith("'*' expects two number values");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* NumV */0,
            _0: Math.imul(a._0, b._0)
          };
  } else {
    return Pervasives.failwith("'*' expects two number values");
  }
}

function div(alon) {
  if (!alon) {
    return Pervasives.failwith("'/' expects two number values");
  }
  var a = alon.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("'/' expects two number values");
  }
  var match = alon.tl;
  if (!match) {
    return Pervasives.failwith("'/' expects two number values");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* NumV */0,
            _0: Caml_int32.div(a._0, b._0)
          };
  } else {
    return Pervasives.failwith("'/' expects two number values");
  }
}

function rem(alon) {
  if (!alon) {
    return Pervasives.failwith("'remainder' expects two number values");
  }
  var a = alon.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("'remainder' expects two number values");
  }
  var match = alon.tl;
  if (!match) {
    return Pervasives.failwith("'remainder' expects two number values");
  }
  var b = match.hd;
  if (b.TAG !== /* NumV */0) {
    return Pervasives.failwith("'remainder' expects two number values");
  }
  if (match.tl) {
    return Pervasives.failwith("'remainder' expects two number values");
  }
  var b$1 = b._0;
  var a$1 = a._0;
  return {
          TAG: /* NumV */0,
          _0: a$1 - Math.imul(b$1, Caml_int32.div(a$1, b$1)) | 0
        };
}

function numEq(alon) {
  if (!alon) {
    return Pervasives.failwith("'=' expects two number values");
  }
  var a = alon.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("'=' expects two number values");
  }
  var match = alon.tl;
  if (!match) {
    return Pervasives.failwith("'=' expects two number values");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* BoolV */1,
            _0: a._0 === b._0
          };
  } else {
    return Pervasives.failwith("'=' expects two number values");
  }
}

function lessThan(alon) {
  if (!alon) {
    return Pervasives.failwith("< expects two number values");
  }
  var a = alon.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("< expects two number values");
  }
  var match = alon.tl;
  if (!match) {
    return Pervasives.failwith("< expects two number values");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* BoolV */1,
            _0: a._0 < b._0
          };
  } else {
    return Pervasives.failwith("< expects two number values");
  }
}

function moreThan(alon) {
  if (!alon) {
    return Pervasives.failwith("> expects two number values");
  }
  var a = alon.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("> expects two number values");
  }
  var match = alon.tl;
  if (!match) {
    return Pervasives.failwith("> expects two number values");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* BoolV */1,
            _0: a._0 > b._0
          };
  } else {
    return Pervasives.failwith("> expects two number values");
  }
}

function lEq(alon) {
  if (!alon) {
    return Pervasives.failwith("<= expects two number values");
  }
  var a = alon.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("<= expects two number values");
  }
  var match = alon.tl;
  if (!match) {
    return Pervasives.failwith("<= expects two number values");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* BoolV */1,
            _0: a._0 <= b._0
          };
  } else {
    return Pervasives.failwith("<= expects two number values");
  }
}

function mEq(alon) {
  if (!alon) {
    return Pervasives.failwith(">= expects two number values");
  }
  var a = alon.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith(">= expects two number values");
  }
  var match = alon.tl;
  if (!match) {
    return Pervasives.failwith(">= expects two number values");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* BoolV */1,
            _0: a._0 >= b._0
          };
  } else {
    return Pervasives.failwith(">= expects two number values");
  }
}

function isEq(alod) {
  if (!alod) {
    return Pervasives.failwith("equal? expects two values of the same type");
  }
  var a = alod.hd;
  switch (a.TAG | 0) {
    case /* NumV */0 :
        var match = alod.tl;
        if (!match) {
          return Pervasives.failwith("equal? expects two values of the same type");
        }
        var b = match.hd;
        if (b.TAG === /* NumV */0 && !match.tl) {
          return {
                  TAG: /* BoolV */1,
                  _0: a._0 === b._0
                };
        } else {
          return Pervasives.failwith("equal? expects two values of the same type");
        }
    case /* BoolV */1 :
        var match$1 = alod.tl;
        if (!match$1) {
          return Pervasives.failwith("equal? expects two values of the same type");
        }
        var b$1 = match$1.hd;
        if (b$1.TAG === /* BoolV */1 && !match$1.tl) {
          return {
                  TAG: /* BoolV */1,
                  _0: a._0 === b$1._0
                };
        } else {
          return Pervasives.failwith("equal? expects two values of the same type");
        }
    case /* ListV */2 :
        var match$2 = alod.tl;
        if (!match$2) {
          return Pervasives.failwith("equal? expects two values of the same type");
        }
        var b$2 = match$2.hd;
        if (b$2.TAG === /* ListV */2 && !match$2.tl) {
          return {
                  TAG: /* BoolV */1,
                  _0: Caml_obj.caml_equal(a._0, b$2._0)
                };
        } else {
          return Pervasives.failwith("equal? expects two values of the same type");
        }
    case /* BuiltinV */3 :
    case /* ClosureV */4 :
        return Pervasives.failwith("equal? expects two values of the same type");
    
  }
}

function isNum(alod) {
  if (alod) {
    if (alod.hd.TAG === /* NumV */0) {
      if (alod.tl) {
        return Pervasives.failwith("num? expects one value");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: true
              };
      }
    } else if (alod.tl) {
      return Pervasives.failwith("num? expects one value");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  } else {
    return Pervasives.failwith("num? expects one value");
  }
}

function isZero(alon) {
  if (!alon) {
    return Pervasives.failwith("zero? expects a number value");
  }
  var num = alon.hd;
  if (num.TAG === /* NumV */0 && !alon.tl) {
    if (num._0 === 0) {
      return {
              TAG: /* BoolV */1,
              _0: true
            };
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  } else {
    return Pervasives.failwith("zero? expects a number value");
  }
}

function cons(alod) {
  if (!alod) {
    return Pervasives.failwith("cons expects inputs of type 'a followed by List('a)");
  }
  var match = alod.tl;
  if (!match) {
    return Pervasives.failwith("cons expects inputs of type 'a followed by List('a)");
  }
  var lst = match.hd;
  if (lst.TAG === /* ListV */2 && !match.tl) {
    return {
            TAG: /* ListV */2,
            _0: {
              hd: alod.hd,
              tl: lst._0
            }
          };
  } else {
    return Pervasives.failwith("cons expects inputs of type 'a followed by List('a)");
  }
}

function first(alod) {
  if (!alod) {
    return Pervasives.failwith("First expects a list with at least 1 element; arguments don't match");
  }
  var match = alod.hd;
  if (match.TAG !== /* ListV */2) {
    return Pervasives.failwith("First expects a list with at least 1 element; arguments don't match");
  }
  var match$1 = match._0;
  if (match$1 && !alod.tl) {
    return match$1.hd;
  } else {
    return Pervasives.failwith("First expects a list with at least 1 element; arguments don't match");
  }
}

function rest(alod) {
  if (!alod) {
    return Pervasives.failwith("Rest expects a list with at least 2 elements; arguments don't match");
  }
  var match = alod.hd;
  if (match.TAG !== /* ListV */2) {
    return Pervasives.failwith("Rest expects a list with at least 2 elements; arguments don't match");
  }
  var match$1 = match._0;
  if (!match$1) {
    return Pervasives.failwith("Rest expects a list with at least 2 elements; arguments don't match");
  }
  var match$2 = match$1.tl;
  if (match$2 && !alod.tl) {
    return {
            TAG: /* ListV */2,
            _0: {
              hd: match$2.hd,
              tl: match$2.tl
            }
          };
  } else {
    return Pervasives.failwith("Rest expects a list with at least 2 elements; arguments don't match");
  }
}

function isEmpty(alod) {
  if (!alod) {
    return Pervasives.failwith("empty? expects an argument of type list('a)");
  }
  var match = alod.hd;
  if (match.TAG === /* ListV */2) {
    if (match._0) {
      if (alod.tl) {
        return Pervasives.failwith("empty? expects an argument of type list('a)");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: false
              };
      }
    } else if (alod.tl) {
      return Pervasives.failwith("empty? expects an argument of type list('a)");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: true
            };
    }
  } else {
    return Pervasives.failwith("empty? expects an argument of type list('a)");
  }
}

function isCons(lst) {
  if (!lst) {
    return Pervasives.failwith("cons? expects an argument of type list('a)");
  }
  var match = lst.hd;
  if (match.TAG === /* ListV */2) {
    if (match._0) {
      if (lst.tl) {
        return Pervasives.failwith("cons? expects an argument of type list('a)");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: true
              };
      }
    } else if (lst.tl) {
      return Pervasives.failwith("cons? expects an argument of type list('a)");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  } else {
    return Pervasives.failwith("cons? expects an argument of type list('a)");
  }
}

function not_(bool) {
  if (!bool) {
    return Pervasives.failwith("not expects an argument of type bool");
  }
  var exp = bool.hd;
  if (exp.TAG === /* BoolV */1 && !bool.tl) {
    return {
            TAG: /* BoolV */1,
            _0: !exp._0
          };
  } else {
    return Pervasives.failwith("not expects an argument of type bool");
  }
}

var initialTle_0 = {
  hd: [
    /* Name */{
      _0: "+"
    },
    {
      TAG: /* BuiltinV */3,
      _0: {
        printedRep: "builtIn: plus",
        bProc: plus
      }
    }
  ],
  tl: {
    hd: [
      /* Name */{
        _0: "-"
      },
      {
        TAG: /* BuiltinV */3,
        _0: {
          printedRep: "builtIn: minus",
          bProc: minus
        }
      }
    ],
    tl: {
      hd: [
        /* Name */{
          _0: "*"
        },
        {
          TAG: /* BuiltinV */3,
          _0: {
            printedRep: "builtIn: multiplication",
            bProc: mult
          }
        }
      ],
      tl: {
        hd: [
          /* Name */{
            _0: "/"
          },
          {
            TAG: /* BuiltinV */3,
            _0: {
              printedRep: "builtIn: division",
              bProc: div
            }
          }
        ],
        tl: {
          hd: [
            /* Name */{
              _0: "remainder"
            },
            {
              TAG: /* BuiltinV */3,
              _0: {
                printedRep: "builtIn: remainder",
                bProc: rem
              }
            }
          ],
          tl: {
            hd: [
              /* Name */{
                _0: "="
              },
              {
                TAG: /* BuiltinV */3,
                _0: {
                  printedRep: "builtIn: equalMath",
                  bProc: numEq
                }
              }
            ],
            tl: {
              hd: [
                /* Name */{
                  _0: "<"
                },
                {
                  TAG: /* BuiltinV */3,
                  _0: {
                    printedRep: "builtIn: less than",
                    bProc: lessThan
                  }
                }
              ],
              tl: {
                hd: [
                  /* Name */{
                    _0: ">"
                  },
                  {
                    TAG: /* BuiltinV */3,
                    _0: {
                      printedRep: "builtIn: more than",
                      bProc: moreThan
                    }
                  }
                ],
                tl: {
                  hd: [
                    /* Name */{
                      _0: "<="
                    },
                    {
                      TAG: /* BuiltinV */3,
                      _0: {
                        printedRep: "builtIn: less than or equal",
                        bProc: lEq
                      }
                    }
                  ],
                  tl: {
                    hd: [
                      /* Name */{
                        _0: ">="
                      },
                      {
                        TAG: /* BuiltinV */3,
                        _0: {
                          printedRep: "builtIn: more than or equal",
                          bProc: mEq
                        }
                      }
                    ],
                    tl: {
                      hd: [
                        /* Name */{
                          _0: "equal?"
                        },
                        {
                          TAG: /* BuiltinV */3,
                          _0: {
                            printedRep: "builtIn: isEqual",
                            bProc: isEq
                          }
                        }
                      ],
                      tl: {
                        hd: [
                          /* Name */{
                            _0: "number?"
                          },
                          {
                            TAG: /* BuiltinV */3,
                            _0: {
                              printedRep: "builtIn: isNum",
                              bProc: isNum
                            }
                          }
                        ],
                        tl: {
                          hd: [
                            /* Name */{
                              _0: "zero?"
                            },
                            {
                              TAG: /* BuiltinV */3,
                              _0: {
                                printedRep: "builtIn: isZero",
                                bProc: isZero
                              }
                            }
                          ],
                          tl: {
                            hd: [
                              /* Name */{
                                _0: "cons"
                              },
                              {
                                TAG: /* BuiltinV */3,
                                _0: {
                                  printedRep: "builtIn: cons",
                                  bProc: cons
                                }
                              }
                            ],
                            tl: {
                              hd: [
                                /* Name */{
                                  _0: "first"
                                },
                                {
                                  TAG: /* BuiltinV */3,
                                  _0: {
                                    printedRep: "builtIn: first",
                                    bProc: first
                                  }
                                }
                              ],
                              tl: {
                                hd: [
                                  /* Name */{
                                    _0: "rest"
                                  },
                                  {
                                    TAG: /* BuiltinV */3,
                                    _0: {
                                      printedRep: "builtin: rest",
                                      bProc: rest
                                    }
                                  }
                                ],
                                tl: {
                                  hd: [
                                    /* Name */{
                                      _0: "empty?"
                                    },
                                    {
                                      TAG: /* BuiltinV */3,
                                      _0: {
                                        printedRep: "builtIn: isEmpty",
                                        bProc: isEmpty
                                      }
                                    }
                                  ],
                                  tl: {
                                    hd: [
                                      /* Name */{
                                        _0: "cons?"
                                      },
                                      {
                                        TAG: /* BuiltinV */3,
                                        _0: {
                                          printedRep: "builtIn: isCons",
                                          bProc: isCons
                                        }
                                      }
                                    ],
                                    tl: {
                                      hd: [
                                        /* Name */{
                                          _0: "not"
                                        },
                                        {
                                          TAG: /* BuiltinV */3,
                                          _0: {
                                            printedRep: "builtIn: not",
                                            bProc: not_
                                          }
                                        }
                                      ],
                                      tl: /* [] */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};

var initialTle = {
  hd: initialTle_0,
  tl: /* [] */0
};

function parseExpression(input) {
  return Pervasives.failwith("parseExpression is not yet implemented");
}

function parseDefinition(input) {
  return Pervasives.failwith("parseDefinition is not yet implemented");
}

function parsePiece(input) {
  switch (input.TAG | 0) {
    case /* NumberC */0 :
    case /* SymbolC */1 :
        return Pervasives.failwith("expressions not yet parsed");
    case /* ListC */2 :
        var match = input._0;
        if (!match) {
          return Pervasives.failwith("expressions not yet parsed");
        }
        var match$1 = match.hd;
        switch (match$1.TAG | 0) {
          case /* SymbolC */1 :
              if (match$1._0 === "define") {
                return Pervasives.failwith("definitions not yet parsed");
              } else {
                return Pervasives.failwith("expressions not yet parsed");
              }
          case /* NumberC */0 :
          case /* ListC */2 :
              return Pervasives.failwith("expressions not yet parsed");
          
        }
    
  }
}

function parse(input) {
  return List.map(parsePiece, input);
}

function $$eval(tle, env, expr) {
  return Pervasives.failwith("eval is not yet implemented");
}

function addDefinition(env, param) {
  return Pervasives.failwith("addDefinition is not yet implemented");
}

function stringOfValue(aValue) {
  return Pervasives.failwith("stringOfValue is not yet implemented");
}

function $$process(pieces) {
  var processHelper = function (_tle, _pieces) {
    while(true) {
      var pieces = _pieces;
      var tle = _tle;
      if (!pieces) {
        return /* [] */0;
      }
      var d = pieces.hd;
      if (d.TAG !== /* Definition */0) {
        return {
                hd: Pervasives.failwith("eval is not yet implemented"),
                tl: processHelper(tle, pieces.tl)
              };
      }
      _pieces = pieces.tl;
      _tle = addDefinition(tle, d._0);
      continue ;
    };
  };
  return processHelper(initialTle, pieces);
}

function rackette(program) {
  return List.map(stringOfValue, $$process(List.map(parsePiece, Read$Rackette.Reader.readAll(program))));
}

CS17SetupRackettePREDESIGNCHECK$Rackette.checkExpectExpression(Pervasives.failwith("parseExpression is not yet implemented"), /* EmptyE */0, "parse empty expression");

CS17SetupRackettePREDESIGNCHECK$Rackette.checkExpectExpression((Read$Rackette.Reader.read("empty"), Pervasives.failwith("parseExpression is not yet implemented")), /* EmptyE */0, "read and parse empty expression");

exports.plus = plus;
exports.minus = minus;
exports.mult = mult;
exports.div = div;
exports.rem = rem;
exports.numEq = numEq;
exports.lessThan = lessThan;
exports.moreThan = moreThan;
exports.lEq = lEq;
exports.mEq = mEq;
exports.isEq = isEq;
exports.isNum = isNum;
exports.isZero = isZero;
exports.cons = cons;
exports.first = first;
exports.rest = rest;
exports.isEmpty = isEmpty;
exports.isCons = isCons;
exports.not_ = not_;
exports.initialTle = initialTle;
exports.parseExpression = parseExpression;
exports.parseDefinition = parseDefinition;
exports.parsePiece = parsePiece;
exports.parse = parse;
exports.$$eval = $$eval;
exports.addDefinition = addDefinition;
exports.stringOfValue = stringOfValue;
exports.$$process = $$process;
exports.rackette = rackette;
/*  Not a pure module */
